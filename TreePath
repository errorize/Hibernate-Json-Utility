package json.node;

import java.util.HashMap;
import java.util.Map;

public class TreePath {
	public int maxDepth = Integer.MIN_VALUE;
	public Map<String, TreeNode> roots = new HashMap<String, TreeNode>();
	
	public TreePath() { }
	public TreePath(String paths[]) {
		addAll(paths);
	}

	private void add(String paths[], TreeNode parent, int depth) {
		if(paths == null || paths.length <= depth) {
			// 避免深度溢出
			return;
		}
		TreeNode temp = parent.children.get(paths[depth]);
		if(temp == null) { // 找不到入口
			temp = new TreeNode();
			parent.children.put(paths[depth], temp);
			for(int i = depth + 1, l = paths.length; i < l; ++i) {
				TreeNode n = new TreeNode();
				temp.children.put(paths[i], n);
				temp = n;
			}
		}
		else {
			add(paths, temp, depth + 1);
		}
	}
	
	public static String[] split(String str, char sep) {
		if(str == null) { return null; }
		int count = 0;
		for(int i = 0, l = str.length(); i < l; ++i) {
			if(str.charAt(i) == sep) { ++count; }
		}
		String[] st = new String[count + 1];  // 合理分配内存空间
		if(count == 0) {
			st[count] = str;
			return st;
		}
		int s = 0;
		for(int i = 0, l = str.length(), j = 0; i < l; ++i) {
			if(str.charAt(i) == sep) {
				st[j++] = str.substring(s, i);
				s = i + 1;
			}
		}
		st[count] = str.substring(s);
		return st;
	}
	
	public void add(String path) {
		String paths[] = split(path, '.');
		if(maxDepth < paths.length) { maxDepth = paths.length; }
		Map<String, TreeNode> nodes = this.roots;
		int depth = 0;
		TreeNode temp = nodes.get(paths[depth]);
		if(temp == null) { // 找不到入口
			temp = new TreeNode();
			this.roots.put(paths[depth], temp);
			for(int i = depth + 1, l = paths.length; i < l; ++i) {
				TreeNode n = new TreeNode();
				temp.children.put(paths[i], n);
				temp = n;
			}
		}
		else {
			add(paths, temp, depth + 1);
		}
	}
	
	public void addAll(String paths[]) {
		for(String path : paths) { this.add(path); }
	}
	
}
